import {
  useMutablePlasmicQueryData,
  usePlasmicDataConfig,
  wrapLoadingFetcher,
} from "@plasmicapp/query";
import * as React from "react";
import { getConfig } from "../common";
import { mapRecordEntries, mapRecords, noopFn, notNil } from "../utils";
import {
  StatefulQueryResult,
  StatefulQueryState,
  SyncPromise,
  resolveParams,
  useRenderEffect,
} from "./common";
import { makeQueryCacheKey } from "./makeQueryCacheKey";
import { PlasmicQuery, PlasmicQueryResult } from "./types";

const GLOBAL_CACHE = new Map<string, SyncPromise<unknown>>();

type StudioCacheWrapper = <F extends (...args: any[]) => Promise<any>>(
  id: string,
  fn: F,
  ...args: Parameters<F>
) => Promise<any>;

/**
 * This hook's job is to execute queries and re-render when query state changes.
 * Data caching can be controlled via @plasmicapp/query.
 *
 * The actual results will be available in $queries generated by
 * createDollarQueries.
 *
 * Prefetched query data can be passed to
 * <PlasmicQueryDataProvider prefetchedCache={...}>.
 *
 * Example codegen:
 *
 * export function create$Queries() {
 *   return createDollarQueries(["result", "dep"]);
 * }
 * type QueryName = keyof ReturnType<typeof create$Queries>;
 * export function createQueries(
 *   $ctx: Record<string, any>,
 *   $queries: Record<QueryName, PlasmicQueryResult>,
 * ) {
 *   return {
 *     result: {
 *       id: "plus",
 *       fn: (a, b) => a + b,
 *       execParams: () => [1, $queries.dep.data],
 *     },
 *     dep: {
 *       id: "times",
 *       fn: (a, b) => a * b,
 *       execParams: () => [2, 3],
 *     },
 *   }
 * }
 *
 * export function ClientComponent() {
 *   const $queries = React.useMemo(create$Queries, []);
 *   const queries = React.useMemo(() => createQueries($queries), [$queries]);
 *   usePlasmicQueries($queries, queries);
 *   return <div>{$queries.result.data}</div> // $queries.result.data may suspend
 * }
 */
export function usePlasmicQueries<QueryName extends string>(
  $queries: Record<QueryName, PlasmicQueryResult>,
  queries: Record<QueryName, PlasmicQuery>
): void {
  // Since we codegen components with data fetching and content rendering
  // together, the component will be suspended when query data is not loaded.
  // Therefore, this hook's primary complexity is handling component suspension
  // while maintaining compatibility with @plasmicapp/query (SWR).
  //
  // Due to component suspension, normal useEffects are not run, so we cannot
  // rely on useMutablePlasmicQueryData to start queries.
  // Instead, we start all queries during the render phase to ensure whichever
  // thrown promise that causes suspense will settle.
  // To ensure we don't start the same query in the render phase and in SWR,
  // we wrap the query functions with logic to check/store promises in the
  // GLOBAL_CACHE, which will contain all promises started outside SWR.
  // After SWR stores the results of these promises in its own cache,
  // we remove the promise from the GLOBAL_CACHE and rely on SWR,
  // since SWR is responsible for other behaviors like revalidation.

  // Wrap queries with the GLOBAL_CACHE.
  const wrappedQueries = React.useMemo(() => wrapQueries(queries), [queries]);
  const $queryStates = $queries as Record<QueryName, StatefulQueryResult>;
  const { fallback: prefetchedCache, cache: swrCache } = usePlasmicDataConfig();

  // Normally, useMutablePlasmicQueryData re-renders when its own query settles.
  // However, useMutablePlasmicQueryData will NOT re-render when its dependent
  // queries settle or get reset due to a prop change.
  // This counter forces useMutablePlasmicQueryData to re-resolve params.
  const [settledCount, setSettledCount] = React.useState(0);
  React.useEffect(() => {
    let cleanup = false;
    const resultListener = (
      next: StatefulQueryState,
      prev: StatefulQueryState
    ) => {
      if (cleanup) {
        return;
      }

      if (prev.state === "done" || next.state === "done") {
        // Queue microtask since the listener may run during the render phase
        // due to useRenderEffect.
        queueMicrotask(() => setSettledCount((v) => v + 1));
      }
    };
    mapRecords((_queryName, $query) => {
      $query.addListener(resultListener);
    }, $queryStates);
    return () => {
      cleanup = true;
      mapRecords((_queryName, $query) => {
        $query.removeListener(resultListener);
      }, $queryStates);
    };
  }, [$queryStates]);

  // Start queries during the render phase with useRenderEffect.
  useRenderEffect(
    (prevDeps) => {
      // If queries/wrappedQueries changed, it means something in the query's
      // execParams closure changed, maybe $ctx or $props.
      // In this case, all existing resolved params may no longer be correct,
      // so we reset all $queries to force re-resolve all params.
      // If the params turn out to be the same as before, then the cached data
      // will be resolved immediately.
      if (prevDeps) {
        const prevWrappedQueries: Record<QueryName, PlasmicQuery> = prevDeps[0];
        if (!Object.is(prevWrappedQueries, wrappedQueries)) {
          mapRecords((_queryName, $query) => {
            $query.reset();
          }, $queryStates);
        }
      }

      // Core loop that starts queries outside SWR and checks caches.
      let cleanup = false;
      const loop = async () => {
        while (true) {
          initPlasmicQueriesSync(
            $queryStates,
            wrappedQueries,
            prefetchedCache,
            swrCache
          );

          const loadingQueries = mapRecordEntries((_queryName, $query) => {
            if ($query.isLoading) {
              return $query.getDoneResult();
            } else {
              return null;
            }
          }, $queryStates).filter(notNil);

          if (loadingQueries.length === 0) {
            break;
          }

          await Promise.race(loadingQueries);
          if (cleanup) {
            break;
          }
        }
      };

      loop()
        // Avoid PromiseRejectionHandledWarning on internal promise
        // that users can't catch.
        .catch(noopFn);
      return () => {
        cleanup = true;
      };
    },
    [wrappedQueries, $queryStates, settledCount]
  );

  mapRecordEntries(
    (_queryName, $query, query) => {
      usePlasmicServerQuery<unknown, (...args: unknown[]) => Promise<unknown>>(
        query,
        undefined,
        {
          settledCount,
          onStarted: $query.loadingPromise.bind($query),
          onResolved: $query.resolvePromise.bind($query),
          onRejected: $query.rejectPromise.bind($query),
        }
      );
    },
    $queryStates,
    wrappedQueries
  );
}

/**
 * Wraps queries with the following logic:
 * - Check GLOBAL_CACHE.
 * - Allow Studio to hook into query execution.
 * - Count number of queries loading globally.
 */
function wrapQueries<QueryName extends string>(
  queries: Record<QueryName, PlasmicQuery>
): Record<QueryName, PlasmicQuery> {
  return mapRecords((_queryName, query: PlasmicQuery) => {
    const wrappedFn = (...args: unknown[]): Promise<unknown> => {
      // Check GLOBAL_CACHE.
      const cacheKey = makeQueryCacheKey(query.id, args);
      const cached = GLOBAL_CACHE.get(cacheKey);
      if (cached) {
        return cached.promise;
      }

      // Allow Studio to hook into query execution.
      const wrapStudioCache: StudioCacheWrapper = getConfig(
        "EXECUTE_SERVER_QUERY",
        (
          _: string,
          fn: (...args2: unknown[]) => Promise<unknown>,
          ...args2: unknown[]
        ) => fn(...args2)
      );

      // Count number of queries loading globally.
      const promise = wrapLoadingFetcher(wrapStudioCache)(
        query.id,
        query.fn,
        ...args
      );

      GLOBAL_CACHE.set(cacheKey, new SyncPromise(promise));
      return promise;
    };
    return {
      id: query.id,
      fn: wrappedFn,
      execParams: query.execParams,
    };
  }, queries);
}

/**
 * Synchronously resolves params and resolves from cache or starts loading.
 * This function does as much as possible without awaiting any promises.
 */
function initPlasmicQueriesSync<QueryName extends string>(
  $queries: Record<QueryName, StatefulQueryResult>,
  queries: Record<QueryName, PlasmicQuery>,
  prefetchedCache: { [k: string]: unknown },
  clientCache: { get: (k: string) => unknown }
): void {
  // Since we don't know the exact order of the dependency graph of queries,
  // we continuously iterate over the queries if any queries were cached from
  // the last iteration.
  let anySettled: boolean;
  do {
    anySettled = false;

    mapRecords(
      (_queryName, $query, query) => {
        if ($query.current.state !== "initial") {
          return;
        }

        const paramsResult = resolveParams(query.execParams);
        if (paramsResult.status === "error") {
          // params errored, reject and don't try again next iteration
          $query.rejectPromise(null, paramsResult.error);
          anySettled = true;
          return;
        } else if (paramsResult.status === "blocked") {
          // params blocked, try again next iteration if any resolved
          return;
        } // else paramsResult.status === "ready

        const cacheKey = makeQueryCacheKey(
          query.id,
          paramsResult.resolvedParams
        );

        // Try prefetched cache
        if (cacheKey in prefetchedCache) {
          $query.resolvePromise(cacheKey, prefetchedCache[cacheKey]);
          anySettled = true;
          return;
        }

        // Try SWR cache
        const clientCacheData = clientCache.get(cacheKey);
        if (clientCacheData !== undefined) {
          $query.resolvePromise(cacheKey, clientCacheData);
          anySettled = true;
          return;
        }

        // Try global cache
        const clientCachedPromise = GLOBAL_CACHE.get(cacheKey);
        if (clientCachedPromise?.result) {
          if (clientCachedPromise.result.state === "resolved") {
            $query.resolvePromise(cacheKey, clientCachedPromise.result.value);
          } else {
            $query.rejectPromise(cacheKey, clientCachedPromise.result.error);
          }
          anySettled = true;
          return;
        }

        // Start loading
        $query.loadingPromise(
          cacheKey,
          query.fn(...paramsResult.resolvedParams)
        );
      },
      $queries,
      queries
    );
  } while (anySettled);
}

/**
 * @deprecated
 * This export will be deleted before RSC release.
 * TODO: Rename to usePlasmicQuery
 * TODO: Reference $query directly.
 * TODO: Use paramsResult from usePlasmicQueries
 */
export function usePlasmicServerQuery<
  T,
  F extends (...args: any[]) => Promise<T>
>(
  query: PlasmicQuery<F>,
  fallbackData?: T,
  opts?: {
    noUndefinedDataProxy?: boolean;
    settledCount?: number;
    onStarted?: (key: string, promise: Promise<T>) => void;
    onResolved?: (key: string, data: T) => void;
    onRejected?: (key: string | null, error: unknown) => void;
  }
): Partial<PlasmicQueryResult<T>> {
  // Since query.execParams never changes, we need a way to know when to retry
  // resolving params. The parent can pass in settledCount that increments as
  // queries settle.
  const paramsResult = React.useMemo(() => {
    return resolveParams(query.execParams);
  }, [query.execParams, opts?.settledCount]);

  const { key, fetcher } = React.useMemo((): {
    key: string | null;
    fetcher: () => Promise<T>;
  } => {
    switch (paramsResult.status) {
      case "blocked":
      case "error": {
        return {
          key: null,
          fetcher: () => {
            throw new Error("fetcher unexpectedly invoked");
          },
        };
      }
      case "ready": {
        const cacheKey = makeQueryCacheKey(
          query.id,
          paramsResult.resolvedParams
        );
        return {
          key: cacheKey,
          fetcher: () => {
            const promise = query.fn(...paramsResult.resolvedParams);
            opts?.onStarted?.(cacheKey, promise);
            return promise.finally(() => {
              GLOBAL_CACHE.delete(cacheKey);
            });
          },
        };
      }
    }
  }, [query, paramsResult]);

  const result = useMutablePlasmicQueryData(key, fetcher, {
    // If revalidateIfStale is true, then if there's a cache entry with a key,
    // but no mounted hook with that key yet, and when the hook mounts with the key,
    // swr will revalidate. This may be reasonable behavior, but for us, this
    // happens all the time -- we prepopulate the cache with proxy-invoked fetch,
    // sometimes before swr had a chance to run the effect.  So we turn off
    // revalidateIfStale here, and just let the user manage invalidation.
    revalidateIfStale: false,

    // TODO: Remove per-hook fallbackData
    // Only used in older server query implementation.
    // New implementation should use prefetchedCache instead.
    fallbackData,
  });

  // TODO: needed?
  if (!result.isLoading) {
    if (result.error) {
      opts?.onRejected?.(key, result.error);
    } else if (key && result.data !== undefined) {
      opts?.onResolved?.(key, result.data);
    }
  }

  return result;
}

export const _testonly = {
  GLOBAL_CACHE,
};
