/** @format */
// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import { Preset } from "@/wab/client/code-components/code-presets";
import {
  AsChildInsertRelLoc,
  AsSiblingInsertRelLoc,
  InsertRelLoc,
  isAsChildRelLoc,
  isAsSiblingRelLoc,
} from "@/wab/client/components/canvas/view-ops";
import { getPreInsertionProps } from "@/wab/client/components/modals/PreInsertionModal";
import {
  checkAndNotifyUnsupportedHostVersion,
  checkAndNotifyUnsupportedReactVersion,
  notifyCodeLibraryInsertion,
} from "@/wab/client/components/modals/codeComponentModals";
import {
  getPlumeComponentTemplates,
  getPlumeImage,
} from "@/wab/client/components/plume/plume-display-utils";
import { PlumyIcon } from "@/wab/client/components/plume/plume-markers";
import { ImagePreview } from "@/wab/client/components/style-controls/ImageSelector";
import { Icon } from "@/wab/client/components/widgets/Icon";
import {
  AddFakeItem,
  AddInstallableItem,
  AddItem,
  AddItemType,
  AddTplItem,
  INSERTABLE_TEMPLATE_COMPONENT_KEY_PREFIX,
  isTplAddItem,
} from "@/wab/client/definitions/insertables";
import {
  COMBINATION_ICON,
  COMPONENT_ICON,
  GROUP_ICON,
} from "@/wab/client/icons";
import {
  buildInsertableExtraInfo,
  getHostLessDependenciesToInsertableTemplate,
  getScreenVariantToInsertableTemplate,
  postInsertableTemplate,
} from "@/wab/client/insertable-templates";
import { analytics } from "@/wab/client/observability";
import PlumeMarkIcon from "@/wab/client/plasmic/plasmic_kit_design_system/icons/PlasmicIcon__PlumeMark";
import { promptChooseInstallableDependencies } from "@/wab/client/prompts";
import { StudioCtx } from "@/wab/client/studio-ctx/StudioCtx";
import { ViewCtx } from "@/wab/client/studio-ctx/view-ctx";
import { getParentOrSlotSelection } from "@/wab/shared/SlotUtils";
import { getBaseVariant } from "@/wab/shared/Variants";
import { usedHostLessPkgs } from "@/wab/shared/cached-selectors";
import {
  appendCodeComponentMetaToModel,
  isPlainObjectPropType,
  syncPlumeComponent,
} from "@/wab/shared/code-components/code-components";
import {
  assert,
  ensure,
  ensureArray,
  hackyCast,
  replaceAll,
  spawn,
  withoutNils,
} from "@/wab/shared/common";
import {
  CodeComponent,
  DefaultComponentKind,
  getComponentDisplayName,
  getDefaultComponentLabel,
  isCodeComponent,
  isPlumeComponent,
  sortComponentsByName,
} from "@/wab/shared/core/components";
import { codeLit } from "@/wab/shared/core/exprs";
import { ImageAssetType } from "@/wab/shared/core/image-asset-type";
import { syncGlobalContexts } from "@/wab/shared/core/project-deps";
import { isTagListContainer } from "@/wab/shared/core/rich-text-util";
import { SlotSelection } from "@/wab/shared/core/slots";
import { unbundleProjectDependency } from "@/wab/shared/core/tagged-unbundle";
import * as Tpls from "@/wab/shared/core/tpls";
import {
  HostLessComponentInfo,
  HostLessPackageInfo,
  InsertableTemplatesComponent,
  InsertableTemplatesItem,
  Installable,
} from "@/wab/shared/devflags";
import { Rect } from "@/wab/shared/geom";
import {
  cloneInsertableTemplate,
  cloneInsertableTemplateArena,
  cloneInsertableTemplateComponent,
} from "@/wab/shared/insertable-templates";
import {
  CloneOpts,
  InsertableTemplateArenaExtraInfo,
  InsertableTemplateComponentExtraInfo,
  InsertableTemplateExtraInfo,
} from "@/wab/shared/insertable-templates/types";
import {
  Arena,
  Component,
  Expr,
  ImageAsset,
  ProjectDependency,
  TplNode,
  isKnownTplNode,
} from "@/wab/shared/model/classes";
import { isRenderableType } from "@/wab/shared/model/model-util";
import {
  canAddChildren,
  canAddSiblings,
  getSlotLikeType,
} from "@/wab/shared/parenting";
import { getPlumeEditorPlugin } from "@/wab/shared/plume/plume-registry";
import { notification } from "antd";
import { mapValues, uniqBy } from "lodash";
import * as React from "react";

export function createAddTplImage(asset: ImageAsset): AddTplItem {
  return {
    type: AddItemType.tpl as const,
    key: `tpl-image-${asset.uuid}`,
    label: asset.name,
    canWrap: false,
    icon: (
      <ImagePreview
        style={{ width: 24, height: 24 }}
        uri={ensure(asset.dataUri, "asset should have dataUri")}
      />
    ),
    factory: (vc: ViewCtx) => vc.variantTplMgr().mkTplImage({ asset: asset }),
  };
}

type CreateAddInstallableExtraInfo = InsertableTemplateExtraInfo & {
  component?: Component;
  arena?: Arena;
};

export function isInsertableTemplateArenaExtraInfo(
  extraInfo: CreateAddInstallableExtraInfo
): extraInfo is InsertableTemplateArenaExtraInfo {
  return !!extraInfo.arena;
}

export function isInsertableTemplateComponentExtraInfo(
  extraInfo: CreateAddInstallableExtraInfo
): extraInfo is InsertableTemplateComponentExtraInfo {
  return !!extraInfo.component;
}

const getSiteByProjectId = async (studioCtx: StudioCtx, projectId: string) => {
  const { pkg: pkgInfo } = await studioCtx.appCtx.api.getPkgByProjectId(
    projectId
  );

  const { pkg, depPkgs } = await (pkgInfo
    ? studioCtx.appCtx.api.getPkgVersion(pkgInfo.id)
    : {});

  assert(pkgInfo && pkg && depPkgs, "Unable to load project");

  const { site } = unbundleProjectDependency(
    studioCtx.bundler(),
    pkg,
    depPkgs
  ).projectDependency;

  assert(site, `Unable to install ${pkgInfo.name}`);

  return site;
};

export function createAddInstallable(meta: Installable): AddInstallableItem {
  return {
    type: AddItemType.installable as const,
    key: `installable-${meta.name}` as const,
    label: meta.name,
    isPackage: true,
    isNew: meta.isNew,
    previewImageUrl: meta.imageUrl,
    projectId: meta.projectId,
    icon: GROUP_ICON,
    asyncExtraInfo: async (
      sc
    ): Promise<CreateAddInstallableExtraInfo | undefined> => {
      const { projectId } = meta;
      const { screenVariant } = await getScreenVariantToInsertableTemplate(sc);
      const installableSite = await getSiteByProjectId(sc, projectId);
      const deps = await promptChooseInstallableDependencies(
        sc,
        installableSite
      );

      if (!deps) {
        return undefined;
      }

      return sc.app.withSpinner(
        (async () => {
          await Promise.all(
            deps.map((dep) =>
              sc.projectDependencyManager.maybeAddDependency(dep)
            )
          );

          const commonInfo: InsertableTemplateExtraInfo = {
            site: installableSite,
            screenVariant,
            ...(await getHostLessDependenciesToInsertableTemplate(
              sc,
              installableSite
            )),
            projectId,
            resolution: {
              token: "reuse-by-name",
              component: "reuse",
            },
          };

          if (meta.entryPoint.type === "arena") {
            const arena = installableSite.arenas.find(
              (c) => c.name === meta.entryPoint.name
            );

            if (!arena) {
              // Happens when maybe devflag does not have the right info. E.g. there is no arena named "Abc" for devflag installable item `entryPoint: {type: "arena", name: "abc"}`
              throw new Error(
                `Failed to install ${meta.name} - Arena ${meta.entryPoint.name} was not found`
              );
            }

            return {
              ...commonInfo,
              arena,
            };
          }

          const component = installableSite.components.find(
            (c) => c.name === meta.entryPoint.name
          );

          if (!component) {
            // Happens when maybe devflag does not have the right info
            throw new Error(
              `Failed to install ${meta.name} - Component ${meta.entryPoint.name} was not found`
            );
          }

          return {
            ...commonInfo,
            component,
          };
        })()
      );
    },
    factory: (sc: StudioCtx, extraInfo: CreateAddInstallableExtraInfo) => {
      if (!extraInfo) {
        return;
      }
      if (
        meta.entryPoint.type === "arena" &&
        isInsertableTemplateArenaExtraInfo(extraInfo)
      ) {
        const { arena, seenFonts } = cloneInsertableTemplateArena(
          sc.site,
          extraInfo
        );

        postInsertableTemplate(sc, seenFonts);
        return arena;
      } else if (
        meta.entryPoint.type === "component" &&
        isInsertableTemplateComponentExtraInfo(extraInfo)
      ) {
        const { component, seenFonts } = cloneInsertableTemplateComponent(
          sc.site,
          extraInfo,
          sc.projectDependencyManager.plumeSite
        );
        postInsertableTemplate(sc, seenFonts);

        return component;
      }
      return;
    },
  };
}

function cloneTemplateComponent(
  vc: ViewCtx,
  {
    skipDuplicateCheck,
    isDragging,
    ...extraInfo
  }: CreateAddTemplateComponentExtraInfo
) {
  // Only tracks new standalone installations of component templates
  analytics().track("Insertable template component", {
    // For backwards compatibility
    insertableName: `${extraInfo.projectId}-${extraInfo.component.name}`,
    // new fields
    sourceProjectId: extraInfo.projectId,
    sourceComponentId: extraInfo.component.uuid,
    sourceComponentName: extraInfo.component.name,
  });
  const { component: comp, seenFonts } = cloneInsertableTemplateComponent(
    vc.site,
    extraInfo,
    vc.studioCtx.projectDependencyManager.plumeSite,
    { skipDuplicateCheck, isDragging }
  );
  postInsertableTemplate(vc.studioCtx, seenFonts);
  return addTplComponent(vc, comp);
}

function addTplComponent(vc: ViewCtx, component: Component) {
  const tpl = vc.variantTplMgr().mkTplComponentWithDefaults(component);
  const plugin = getPlumeEditorPlugin(tpl.component);
  if (plugin) {
    plugin.onComponentInserted?.(component, tpl);
  }
  return tpl;
}

export function createAddTplComponent(
  component: Component
): AddTplItem<CreateAddTplComponentExtraInfo> {
  return {
    type: AddItemType.tpl as const,
    key: `tpl-component-${component.uuid}`,
    label: getComponentDisplayName(component),
    systemName: component.name,
    canWrap: false,
    icon: isPlumeComponent(component) ? (
      <PlumyIcon>{COMPONENT_ICON}</PlumyIcon>
    ) : (
      COMPONENT_ICON
    ),
    factory: (vc: ViewCtx, extraInfo: CreateAddTplComponentExtraInfo) => {
      if (extraInfo.type === "existing") {
        return addTplComponent(vc, component);
      }

      return cloneTemplateComponent(vc, extraInfo);
    },
    asyncExtraInfo: async (
      sc,
      opts = {}
    ): Promise<CreateAddTplComponentExtraInfo> => {
      const { skipDuplicateCheck } = opts;
      if (!skipDuplicateCheck) {
        return { type: "existing", component };
      }
      if (
        !component.templateInfo?.projectId ||
        !component.templateInfo?.componentId
      ) {
        return { type: "existing", component };
      }
      const { projectId, componentId } = component.templateInfo;
      const { screenVariant } = await getScreenVariantToInsertableTemplate(sc);
      return sc.app.withSpinner(
        (async () => {
          const info = await buildInsertableExtraInfo(
            sc,
            {
              projectId,
              componentId,
            },
            screenVariant
          );
          assert(
            info,
            () =>
              `Template component with id ${component.templateInfo!
                .componentId!} not found`
          );
          return {
            type: "clone",
            ...opts,
            ...info,
          };
        })()
      );
    },
    component,
  };
}

export function createAddTplCodeComponent(
  component: CodeComponent,
  showImages: boolean
): AddTplItem {
  const thumbUrl = component.codeComponentMeta.thumbnailUrl;
  return {
    ...createAddTplComponent(component),
    previewImageUrl: thumbUrl ?? undefined,
    // If we are showing images, we want to show the compact version of the item
    isCompact: showImages,
  };
}

export function createAddTplCodeComponents(
  components: CodeComponent[]
): AddTplItem[] {
  const uniqComponents = uniqBy(components, (c) => c.uuid);
  const shouldShowImages = uniqComponents.some(
    (c) => c.codeComponentMeta.thumbnailUrl
  );
  return sortComponentsByName(uniqComponents)
    .filter(isCodeComponent)
    .map((component) => {
      return createAddTplCodeComponent(component, shouldShowImages);
    });
}

export function createAddComponentPreset(
  studioCtx: StudioCtx,
  component: CodeComponent,
  preset: Preset
): AddTplItem {
  return {
    type: AddItemType.tpl as const,
    key: `preset-${component.uuid}-${preset.name}`,
    label: preset.name,
    icon: COMPONENT_ICON,
    factory: (vc: ViewCtx) => {
      const tpl = Tpls.clone(preset.tpl);
      const targetVariants = [vc.variantTplMgr().getBaseVariantForNewNode()];
      [...Tpls.findVariantSettingsUnderTpl(tpl)].forEach(([vs]) => {
        replaceAll(vs.variants, targetVariants);
      });
      return tpl;
    },
    previewImageUrl: preset.screenshot,
  };
}

/**
 * Creates an Insert Panel entry that lets you add the "flattened contents" of a template component to the canvas. No new component is auto-created in the destination project.
 * E.g. dragging in a Plexus Button should add the contents of the Plexus Button to the canvas. No new Plexus Button component is created in the destination project.
 * @param meta
 * @returns
 */
export function createAddInsertableTemplate(
  meta: InsertableTemplatesItem
): AddTplItem<InsertableTemplateComponentExtraInfo> {
  return {
    type: AddItemType.tpl as const,
    key: `insertable-template-item-${meta.projectId}-${meta.componentName}`,
    label: meta.componentName,
    projectId: meta.projectId,
    canWrap: false,
    icon: COMBINATION_ICON,
    previewImageUrl: meta.imageUrl,
    factory: (
      vc: ViewCtx,
      extraInfo: InsertableTemplateComponentExtraInfo,
      _drawnRect?: Rect
    ) => {
      // Keeping this event for backwards compatibility
      analytics().track("Insertable template", {
        insertableName: extraInfo.component.name,
        // new fields
        sourceProjectId: extraInfo.projectId,
      });
      const targetComponent = vc.currentComponent();
      const { tpl, seenFonts } = cloneInsertableTemplate(
        vc.site,
        extraInfo,
        getBaseVariant(targetComponent),
        vc.studioCtx.projectDependencyManager.plumeSite,
        targetComponent
      );
      postInsertableTemplate(vc.studioCtx, seenFonts);
      return tpl;
    },
    asyncExtraInfo: async (
      sc,
      opts
    ): Promise<InsertableTemplateComponentExtraInfo> => {
      const screenVariant = !opts?.isDragging
        ? (await getScreenVariantToInsertableTemplate(sc)).screenVariant
        : undefined;
      return sc.app.withSpinner(
        (async () => {
          const info = await buildInsertableExtraInfo(sc, meta, screenVariant);
          assert(info, () => `Cannot find template for ${meta.componentName}`);
          return info;
        })()
      );
    },
  };
}

type CreateAddTemplateComponentExtraInfo =
  InsertableTemplateComponentExtraInfo & CloneOpts;

type CreateAddTplComponentExtraInfo =
  | { type: "existing"; component: Component }
  | ({ type: "clone" } & CreateAddTemplateComponentExtraInfo);

/**
 * Creates an Insert Panel entry that lets you add the template component to the canvas.
 * A new component is auto-created in the destination project.
 * Subsequent insertions will re-use this component, instead of creating a new one every time.
 * E.g. dragging in a Plexus Button should create a new Plexus Button component (if it doesn't already exist), and then add it to the canvas.
 * @param meta
 * @returns
 */
export function createAddTemplateComponent(
  meta: InsertableTemplatesComponent
): AddTplItem<CreateAddTemplateComponentExtraInfo> {
  return {
    type: AddItemType.tpl as const,
    key: `${INSERTABLE_TEMPLATE_COMPONENT_KEY_PREFIX}-${meta.projectId}-${meta.componentName}`,
    label: meta.displayName ?? meta.componentName,
    canWrap: false,
    icon: COMBINATION_ICON,
    previewImageUrl: meta.imageUrl,
    factory: (vc: ViewCtx, extraInfo: CreateAddTemplateComponentExtraInfo) =>
      cloneTemplateComponent(vc, extraInfo),
    asyncExtraInfo: async (
      sc,
      opts = {}
    ): Promise<CreateAddTemplateComponentExtraInfo> => {
      const { screenVariant } = await getScreenVariantToInsertableTemplate(sc);
      return sc.app.withSpinner(
        (async () => {
          const info = await buildInsertableExtraInfo(sc, meta, screenVariant);
          assert(
            info,
            () => `Template component ${meta.componentName} not found`
          );
          return {
            type: "clone",
            ...opts,
            ...info,
          };
        })()
      );
    },
  };
}

export type HostLessComponentExtraInfo = {
  dep: ProjectDependency[];
  component: Component | undefined;
  args?: Record<string, Expr>;
};

export function createAddHostLessComponent(
  meta: HostLessComponentInfo,
  projectIds: string[]
): AddTplItem<HostLessComponentExtraInfo | false> {
  return {
    type: AddItemType.tpl as const,
    key: `hostless-component-${meta.componentName}`,
    systemName: meta.componentName,
    label: meta.displayName,
    canWrap: false,
    icon: COMBINATION_ICON,
    previewImageUrl: meta.imageUrl,
    previewVideoUrl: meta.videoUrl,
    factory: (vc, ctx) => {
      if (!ctx) {
        return undefined;
      }
      const { component, args } = ctx;
      if (
        checkAndNotifyUnsupportedHostVersion(meta.requiredHostVersion) ||
        !component
      ) {
        return undefined;
      }
      return vc.variantTplMgr().mkTplComponentX({
        component,
        args,
      });
    },
    asyncExtraInfo: async (sc, opts) => {
      return await sc.app.withSpinner(
        (async () => {
          const { deps } = await installHostlessPkgs(sc, projectIds);
          if (!deps) {
            return false;
          }
          const component = ensure(
            deps
              .flatMap((dep2) => dep2.site.components)
              .find((c) => c.name === meta.componentName.split("/")[0]),
            "comp should exist"
          );
          const ccMeta = component && sc.getCodeComponentMeta(component);
          const args = meta.args
            ? mapValues(meta.args, (v) => codeLit(v))
            : undefined;
          if (
            opts?.isDragging ||
            !ccMeta ||
            !hackyCast(ccMeta).preInsertion ||
            !sc.appCtx.appConfig.schemaDrivenForms
          ) {
            return { dep: deps, component, args };
          }
          const argsPre = await getPreInsertionProps(sc, component);
          return args ? { dep: deps, component, args: argsPre } : false;
        })()
      );
    },
  };
}

export function createInstallOnlyPackage(
  meta: HostLessComponentInfo,
  packageMeta: HostLessPackageInfo
): AddFakeItem<HostLessComponentExtraInfo | false> {
  const projectIds = ensureArray(packageMeta.projectId);
  return {
    type: AddItemType.fake as const,
    key: `hostless-component-${meta.componentName}`,
    label: meta.displayName,
    icon: COMBINATION_ICON,
    isPackage: true,
    hostLessPackageInfo: packageMeta,
    hostLessComponentInfo: meta,
    previewImageUrl: meta.imageUrl,
    previewVideoUrl: meta.videoUrl,
    factory: (sc, ctx) => {
      if (!ctx || checkAndNotifyUnsupportedHostVersion()) {
        return false;
      }
      if (packageMeta.syntheticPackage) {
        sc.shownSyntheticSections.set(packageMeta.codeName, true);
      }
      return true;
    },
    asyncExtraInfo: async (sc) =>
      sc.app.withSpinner(
        (async () => {
          const { deps } = await installHostlessPkgs(sc, projectIds);
          if (!deps) {
            return false;
          }
          return { dep: deps, component: undefined };
        })()
      ),
  };
}

export function createFakeHostLessComponent(
  meta: HostLessComponentInfo,
  projectIds: string[]
): AddFakeItem<HostLessComponentExtraInfo | false> {
  return {
    type: AddItemType.fake as const,
    key: `hostless-component-${meta.componentName}`,
    label: meta.displayName,
    icon: COMBINATION_ICON,
    monospaced: meta.monospaced,
    description: meta.description,
    previewImageUrl: meta.imageUrl,
    previewVideoUrl: meta.videoUrl,
    factory: (sc, ctx) => {
      if (
        !ctx ||
        checkAndNotifyUnsupportedHostVersion(meta.requiredHostVersion)
      ) {
        return false;
      }
      ctx.dep.forEach((dep) => {
        const isCodeLibrary =
          dep.site.components.length === 0 && dep.site.codeLibraries.length > 0;
        if (!isCodeLibrary) {
          return;
        }
        dep.site.codeLibraries.forEach((lib) => {
          if (!dep.site.hostLessPackageInfo?.name) {
            return;
          }
          notifyCodeLibraryInsertion(
            dep.site.hostLessPackageInfo.name,
            lib.jsIdentifier,
            typeof sc
              .getRegisteredLibraries()
              .find((r) => r.meta.jsIdentifier === lib.jsIdentifier)?.lib
          );
        });
      });
      return true;
    },
    asyncExtraInfo: async (sc) => {
      return sc.app.withSpinner(
        (async () => {
          const { deps } = await installHostlessPkgs(sc, projectIds);
          if (!deps) {
            return false;
          }
          return { dep: deps, component: undefined };
        })()
      );
    },
  };
}

async function installHostlessPkgs(sc: StudioCtx, projectIds: string[]) {
  const existingDep = sc.site.projectDependencies.filter((dep) =>
    projectIds.includes(dep.projectId)
  );
  if (existingDep && existingDep.length === projectIds.length) {
    return {
      deps: existingDep,
    };
  }
  const projectDependencies = existingDep;
  const remainingProjectIds = projectIds.filter(
    (id) => !existingDep.some((dep) => dep.projectId === id)
  );
  for (const projectId of remainingProjectIds) {
    const { pkg: maybePkg } = await sc.appCtx.api.getPkgByProjectId(projectId);
    const pkg = ensure(maybePkg, "pkg must exist");
    const { pkg: latest, depPkgs } = await sc.appCtx.api.getPkgVersion(pkg.id);
    const { projectDependency } = unbundleProjectDependency(
      sc.bundler(),
      latest,
      depPkgs
    );
    projectDependencies.push(projectDependency);
  }

  if (checkAndNotifyUnsupportedReactVersion(projectDependencies)) {
    return { deps: undefined };
  }
  await sc.updateCcRegistry([
    ...usedHostLessPkgs(sc.site),
    ...projectDependencies.flatMap((dep) => usedHostLessPkgs(dep.site)),
  ]);

  await sc.change(({ success }) => {
    for (const projectDependency of projectDependencies) {
      if (
        !sc.site.projectDependencies.some(
          (dep) => dep.pkgId === projectDependency.pkgId
        )
      ) {
        sc.site.projectDependencies.push(projectDependency);
        syncGlobalContexts(projectDependency, sc.site);
        sc.projectDependencyManager.syncDirectDeps();
        maybeShowGlobalContextNotification(sc, projectDependency);
      }
    }
    appendCodeComponentMetaToModel(
      sc.site,
      sc.getCodeComponentsAndContextsRegistration()
    );
    return success();
  });
  return { deps: projectDependencies };
}

export function createAddInsertableIcon(icon: ImageAsset): AddTplItem {
  return {
    type: AddItemType.tpl as const,
    key: `insertable-icon-${icon.uuid}`,
    label: icon.name,
    canWrap: false,
    icon: (
      <ImagePreview
        style={{ width: 24, height: 24 }}
        uri={ensure(icon.dataUri, "icon should have dataUri")}
      />
    ),
    factory: (vc: ViewCtx) => {
      const clonedIcon = vc.tplMgr().addImageAsset({
        name: icon.name,
        type: icon.type as ImageAssetType,
        dataUri: icon.dataUri ?? undefined,
        width: icon.width ?? undefined,
        height: icon.height ?? undefined,
        aspectRatio: icon.aspectRatio ?? undefined,
      });
      return vc.variantTplMgr().mkTplImage({ asset: clonedIcon });
    },
  };
}

export function isInsertable(
  item: AddItem,
  vc: ViewCtx,
  target: TplNode | SlotSelection,
  insertLoc?: InsertRelLoc
) {
  if (!isTplAddItem(item)) {
    return false;
  }
  insertLoc = insertLoc ?? InsertRelLoc.append;
  if (insertLoc === InsertRelLoc.wrap && !item.canWrap) {
    return false;
  }

  if (!isAsChildRelLoc(insertLoc) && !isAsSiblingRelLoc(insertLoc)) {
    return false;
  }

  if (target instanceof SlotSelection && isAsSiblingRelLoc(insertLoc)) {
    // cannot insert as a sibling to a SlotSelection
    return false;
  }

  if (Tpls.isTplTag(target)) {
    if (
      (isTagListContainer(target.tag) && isAsChildRelLoc(insertLoc)) ||
      (target.tag === "li" && isAsSiblingRelLoc(insertLoc))
    ) {
      // Only list items can be added to "ul" and "ol" containers; and only
      // list items can be siblings of list items.
      return item.key === "li";
    }
  }

  const canAdd =
    (isAsChildRelLoc(insertLoc) && canAddChildren(target)) ||
    (isKnownTplNode(target) &&
      isAsSiblingRelLoc(insertLoc) &&
      canAddSiblings(target));

  if (item.type === "plume") {
    // Don't allow inserting new Plume components into constrained
    // slot.  We exit early this way instead of calling item.factory()
    // because doing so will actually create and attach the component
    // to the Site, even before we've done the insertion!
    return !isTargetConstrainedSlot(target, insertLoc) && canAdd;
  }

  if (item.asyncExtraInfo) {
    // Don't create tentatively throwaway tpl to check if it fits into
    // a constrained slot; instead, never allow them in constrained slots
    // for now.
    return !isTargetConstrainedSlot(target, insertLoc) && canAdd;
  }

  const toInsert = item.factory(vc, undefined);
  if (toInsert == null) {
    return false;
  }

  if (isAsChildRelLoc(insertLoc)) {
    return canAddChildren(target, toInsert);
  }

  if (isKnownTplNode(target) && isAsSiblingRelLoc(insertLoc)) {
    return canAddSiblings(target, toInsert);
  }

  return false;
}

function isTargetConstrainedSlot(
  target: TplNode | SlotSelection,
  insertLoc: AsChildInsertRelLoc | AsSiblingInsertRelLoc
) {
  if (isKnownTplNode(target) && isAsSiblingRelLoc(insertLoc)) {
    const parent = getParentOrSlotSelection(target);
    if (!parent) {
      return false;
    }
    target = parent;
  }
  if (Tpls.isTplSlot(target) || target instanceof SlotSelection) {
    const slotType = getSlotLikeType(target);
    if (isRenderableType(slotType)) {
      // Renderable with constraints set in params
      return slotType.params.length > 0;
    } else {
      // some constraint involved
      return false;
    }
  } else {
    return false;
  }
}

export function makePlumeInsertables(
  studioCtx: StudioCtx,
  filteredKind?: DefaultComponentKind
) {
  const plumeSite = studioCtx.projectDependencyManager.plumeSite;
  if (!plumeSite) {
    return [];
  }
  const plumeComponents = getPlumeComponentTemplates(studioCtx);

  const existingTypes = new Set(
    withoutNils([...studioCtx.site.components.map((c) => c.plumeInfo?.type)])
  );

  const items: AddItem[] = [];
  for (const component of plumeComponents) {
    if (
      !existingTypes.has(component.plumeInfo.type) &&
      (!filteredKind || component.plumeInfo.type === filteredKind)
    ) {
      items.push({
        type: AddItemType.plume,
        key: component.uuid,
        label: getDefaultComponentLabel(component.plumeInfo.type),
        canWrap: false,
        icon: <Icon icon={PlumeMarkIcon} />,
        factory: (vc: ViewCtx, extraInfo) => {
          const isComponentInserted = extraInfo.attachComponent;
          const newComponent = studioCtx
            .tplMgr()
            .clonePlumeComponent(
              plumeSite,
              component.uuid,
              component.name,
              isComponentInserted
            );
          syncPlumeComponent(studioCtx, newComponent).match({
            success: (x) => x,
            failure: (err) => {
              throw err;
            },
          });
          const tpl = vc
            .variantTplMgr()
            .mkTplComponentWithDefaults(newComponent);
          if (isComponentInserted) {
            const plugin = getPlumeEditorPlugin(newComponent);
            plugin?.onComponentInserted?.(vc.component, tpl);
          }
          return tpl;
        },
        asyncExtraInfo: async (_studioCtx, opts) => {
          return { attachComponent: !opts?.isDragging };
        },
        previewImageUrl: getPlumeImage(component.plumeInfo.type),
      });
    }
  }
  return items;
}

export function maybeShowGlobalContextNotification(
  studioCtx: StudioCtx,
  projectDependency: ProjectDependency
) {
  const key = "global-context-notification";
  const goToSettings = async () => {
    await studioCtx.change(({ success }) => {
      studioCtx.hideOmnibar();
      studioCtx.switchLeftTab("settings", { highlight: true });
      notification.close(key);
      return success();
    });
  };
  const tryExtractDataSourceProp = (c: Component) => {
    const meta = studioCtx.getHostLessContextsMap().get(c.name);
    if (!meta) {
      return undefined;
    }
    for (const p of c.params) {
      const propType = meta.meta.props[p.variable.name];
      if (
        isPlainObjectPropType(propType) &&
        (propType as any).type === "dataSource"
      ) {
        return [c, p.variable.name] as const;
      }
    }
    return undefined;
  };
  if (projectDependency.site.globalContexts.length > 0) {
    spawn(
      (async () => {
        // Fetch hostless packages
        await studioCtx.updateCcRegistry(usedHostLessPkgs(studioCtx.site));
        for (const globalContext of projectDependency.site.globalContexts) {
          const dataSourceProp = tryExtractDataSourceProp(
            globalContext.component
          );
          if (dataSourceProp) {
            await goToSettings();
            studioCtx.forceOpenProp = dataSourceProp;
            return;
          }
        }
        notification.info({
          message: "Project Settings",
          description: (
            <>
              <p>
                The {projectDependency.name} package can be configured in
                settings.
              </p>
              <a onClick={goToSettings}>Go to settings.</a>
            </>
          ),
          duration: 30,
          key,
        });
      })()
    );
  }
}
