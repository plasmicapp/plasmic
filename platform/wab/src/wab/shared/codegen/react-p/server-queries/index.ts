import { customFunctionId } from "@/wab/shared/code-components/code-components";
import { serializeCustomFunctionsAndLibs } from "@/wab/shared/codegen/react-p/custom-functions";
import { getDataSourcesPackageName } from "@/wab/shared/codegen/react-p/data-sources";
import {
  getDataTokenImportsForPageMeta,
  serializeGenerateDynamicMetadataFunction,
  serializeGenerateMetadataFunction,
} from "@/wab/shared/codegen/react-p/page-metadata";
import { serializeGeneratePageMetadataBody } from "@/wab/shared/codegen/react-p/page-metadata/serializer";
import {
  makeDefaultExternalPropsName,
  makePlasmicComponentName,
  makeServerPageSkeletonPropsName,
  makeTaggedPlasmicImport,
} from "@/wab/shared/codegen/react-p/serialize-utils";
import {
  makeComponentTypeImport,
  makeLoaderServerFunctionFileName,
  makePlasmicClientRscComponentFileName,
  makePlasmicClientRscComponentName,
  makePlasmicServerRscComponentFileName,
  makePlasmicServerRscComponentName,
  serializeMakeAppRouterPageCtx,
  serializeServerQueryCustomFunctionArgs,
} from "@/wab/shared/codegen/react-p/server-queries/serializer";
import { isServerQueryWithOperation } from "@/wab/shared/codegen/react-p/server-queries/utils";
import { SerializerBaseContext } from "@/wab/shared/codegen/react-p/types";
import { ComponentExportOutput, ExportOpts } from "@/wab/shared/codegen/types";
import { toVarName } from "@/wab/shared/codegen/util";
import { assert } from "@/wab/shared/common";
import { isPageComponent } from "@/wab/shared/core/components";
import { flattenExprs } from "@/wab/shared/core/tpls";
import {
  extractDataTokenIdentifiers,
  isDataTokenExpr,
} from "@/wab/shared/eval/expression-parser";
import { ComponentServerQuery } from "@/wab/shared/model/classes";

export function getRscMetadata(
  ctx: SerializerBaseContext
): ComponentExportOutput["rscMetadata"] {
  if (!isPageComponent(ctx.component) || !ctx.useRSC) {
    return undefined;
  }

  const serverQueriesExecFunc = serializeServerPageQueriesLoader(ctx);
  const generateMetadataFunc = serializeGenerateMetadataFunction(ctx);

  return {
    pageWrappers: {
      server: {
        module: serializeServerQueriesServerWrapper(ctx, ctx.exportOpts),
        fileName: makePlasmicServerRscComponentFileName(ctx.component),
      },
      client: {
        module: serializeServerQueriesClientWrapper(ctx, ctx.exportOpts),
        fileName: makePlasmicClientRscComponentFileName(ctx.component),
      },
    },
    serverQueriesExecFunc,
    generateMetadataFunc,
  };
}

function serializeServerComponentBodyWithQueries() {
  return `const { params, searchParams, ...rest } = props;
  const ctx = await makeAppRouterPageCtx({ params, searchParams });

  const serverQueries = create$Queries();
  const prefetchedCache = await unstable_executePlasmicQueries(
    serverQueries,
    createQueries(serverQueries, ctx),
  );
`;
}

function serializeServerQueriesServerWrapper(
  ctx: SerializerBaseContext,
  opts: ExportOpts
) {
  const { component } = ctx;

  assert(isPageComponent(component), "Expected page component");

  const componentName = makePlasmicServerRscComponentName(component);
  const componentPropsName = `${componentName}Props`;
  const clientComponentName = makePlasmicClientRscComponentName(component);
  const genPropsName = makeDefaultExternalPropsName(component);
  const skeletonPropsName = makeServerPageSkeletonPropsName(component);

  return `
/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: ${ctx.projectConfig.projectId}
// Component: ${component.uuid}
// plasmic-unformatted

import * as React from "react";
${makeComponentTypeImport(opts, component)}

${makeTaggedPlasmicImport(
  clientComponentName,
  makePlasmicClientRscComponentFileName(component),
  component.uuid,
  "rscClient"
)}

${serializeServerPageQueries(ctx)}

${serializeMakeAppRouterPageCtx(ctx, skeletonPropsName)}

export type ${componentPropsName} = ${genPropsName} & ${skeletonPropsName};

export async function ${componentName}(props: ${componentPropsName}) {
  ${ctx.hasServerQueries ? serializeServerComponentBodyWithQueries() : ""}

  return (${
    ctx.hasServerQueries
      ? `
    <PlasmicQueryDataProvider prefetchedCache={prefetchedCache}>
      <${clientComponentName} {...rest} />
    </PlasmicQueryDataProvider>`
      : `<${clientComponentName} {...props} />`
  }
  )
}
  `;
}

function serializeServerQueriesClientWrapper(
  ctx: SerializerBaseContext,
  opts: ExportOpts
) {
  const { component } = ctx;

  const componentName = makePlasmicClientRscComponentName(component);
  const plasmicComponentName = makePlasmicComponentName(component);
  const defaultPropsName = makeDefaultExternalPropsName(component);

  return `
"use client";

import * as React from "react";
${makeComponentTypeImport(opts, component, { includePlasmicComponent: true })}

export function ${componentName}(props: ${defaultPropsName}) {
  return (
    <${plasmicComponentName} {...props} />
  )
}
`;
}

/**
 * Extract data token identifiers from server query expressions
 */
export function getDataTokensFromServerQueries(
  queries: ComponentServerQuery[]
): Set<string> {
  // Flatten all server query arg Exprs and extract their data token references
  const tokenIdentifiers = queries
    .filter(isServerQueryWithOperation)
    .flatMap((query) => query.op.args)
    .flatMap(flattenExprs)
    .filter(isDataTokenExpr)
    .flatMap(extractDataTokenIdentifiers);
  return new Set(tokenIdentifiers);
}

export function serializeCreateDollarQueries(ctx: SerializerBaseContext) {
  if (!ctx.hasServerQueries) {
    return "";
  }

  const { component } = ctx;
  const serverQueries = component.serverQueries.filter(
    isServerQueryWithOperation
  );

  return `
export function create$Queries() {
  return unstable_createDollarQueries([${serverQueries
    .map((query) => `"${toVarName(query.name)}"`)
    .join(",")}]);
}

type QueryName = keyof ReturnType<typeof create$Queries>;

export function createQueries(
  $q: Record<QueryName, PlasmicQueryResult>,
  $ctx: any,
): Record<QueryName, PlasmicQuery> {
  return {
    ${serverQueries
      .map(({ op, name }) => {
        const namespace = op.func.namespace ? `${op.func.namespace}.` : "";
        return `${toVarName(name)}: {
          id: "${customFunctionId(op.func)}",
          fn: $$.${namespace}${op.func.importName},
          execParams: () => [
            ${serializeServerQueryCustomFunctionArgs(op, ctx.exprCtx)}
          ],
        }`;
      })
      .join(",\n")}
  };
};`;
}

function serializeServerPageQueries(ctx: SerializerBaseContext) {
  const { component } = ctx;
  const { customFunctionsAndLibsImport, serializedCustomFunctionsAndLibs } =
    serializeCustomFunctionsAndLibs(ctx);

  const dataTokenImports = getDataTokenImportsForPageMeta(
    ctx,
    component.pageMeta
  );

  const serverQueryImports = ctx.hasServerQueries
    ? `
import { unstable_createDollarQueries, unstable_executePlasmicQueries } from "${getDataSourcesPackageName()}";
import type { PlasmicQuery, PlasmicQueryResult } from "${getDataSourcesPackageName()}";
import { PlasmicQueryDataProvider } from "@plasmicapp/react-web/lib/query";`
    : "";

  const module = `
${customFunctionsAndLibsImport}

${serializedCustomFunctionsAndLibs}

${dataTokenImports}
${serverQueryImports}

${serializeGenerateDynamicMetadataFunction(ctx)}
${serializeCreateDollarQueries(ctx)}
`;
  return module;
}

/**
 * Serialize a function to execute page queries for the loader.
 */
function serializeServerPageQueriesLoader(ctx: SerializerBaseContext) {
  const executeServerQueriesBody = ctx.hasServerQueries
    ? `const serverQueries = create$Queries();
  const prefetchedCache = await unstable_executePlasmicQueries(
    serverQueries,
    createQueries(serverQueries, ctx)
  );
  return prefetchedCache;`
    : `return {};`;

  const module = `${serializeServerPageQueries(ctx)}
export async function executeServerQueries(ctx: any) {
  ${executeServerQueriesBody}
}`;
  return {
    module,
    fileName: makeLoaderServerFunctionFileName(ctx.component),
  };
}

export function getPageRouterSkeletonImports(
  ctx: SerializerBaseContext,
  isDynamicRoute: boolean
) {
  let imports = `import { useRouter } from "next/router";
import { PlasmicQueryDataProvider } from "@plasmicapp/react-web/lib/query";`;
  if (ctx.hasServerQueries || ctx.usesComponentLevelQueries) {
    const nextTypes = isDynamicRoute
      ? "GetStaticPaths, GetStaticProps"
      : "GetStaticProps";
    imports += `
import type { ${nextTypes} } from "next";
import { extractPlasmicQueryData } from "@plasmicapp/react-web/lib/prepass";`;
  }
  return imports;
}

export function getAppRouterSkeletonImports({
  hasServerQueries,
}: Pick<SerializerBaseContext, "hasServerQueries">) {
  return `
${
  hasServerQueries
    ? `import { unstable_executePlasmicQueries } from "${getDataSourcesPackageName()}";`
    : ""
}
import type { Metadata, ResolvingMetadata } from "next";`;
}

/**
 * Serialize getStaticProps and imports for Next.js Pages Router skeleton.
 * Uses extractPlasmicQueryData to render the component and extract query data.
 */
export function serializePagesRouterGetStaticProps(
  componentName: string,
  pagePath: string
): string {
  const getStaticProps = `
export const getStaticProps: GetStaticProps = async (context) => {
  const queryCache = await extractPlasmicQueryData(
    <PageParamsProvider__
      route={"${pagePath}"}
      params={context.params}
    >
      <${componentName} />
    </PageParamsProvider__>
  );
  return {
    props: { queryCache },
  };
};
`;

  return getStaticProps;
}

/**
 * Serialize getStaticPaths for Next.js Pages Router dynamic routes.
 */
export function serializePagesRouterGetStaticPaths(): string {
  return `
export const getStaticPaths: GetStaticPaths = async () => {
  console.warn("getStaticPaths was called with an empty paths array. Update this with the set of pages you want to generate statically.");
  return {
    paths: [],
    fallback: "blocking",
  };
};
`;
}

/**
 * Serialize generateMetadata for Next.js App Router skeleton
 * Uses executeServerQueries to get dynamic data
 */
export function serializeAppRouterGenerateMetadata(ctx: SerializerBaseContext) {
  const { component, hasServerQueries } = ctx;
  const skeletonPropsName = makeServerPageSkeletonPropsName(component);

  return `
export async function generateMetadata(
  { params, searchParams }: ${skeletonPropsName},
  parent: ResolvingMetadata
): Promise<Metadata> {
  ${serializeGeneratePageMetadataBody({ hasServerQueries })}

  return { ...(await parent), ...metadata } as unknown as Metadata;
}
`;
}
