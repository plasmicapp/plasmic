// @ts-nocheck
// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import { AuthData } from "@/AuthForm";
import KeyValueRow from "@/KeyValueRow";
import { RestQuery } from "@/wab/classes";
import * as React from "react";
import { useMemo, useState } from "react";
import {
  Controller,
  FormProvider,
  useFieldArray,
  useForm,
} from "react-hook-form";
import util from "util";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import { ValueViewer } from "@/wab/client/components/coding/ValueViewer";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import {
  ReadablePromiseLoadable,
  Spinner,
} from "@/wab/client/components/widgets";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import { LabelWithDetailedTooltip } from "@/wab/client/components/widgets/LabelWithDetailedTooltip";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import Select from "@/wab/client/components/widgets/Select";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import { Textbox } from "@/wab/client/components/widgets/Textbox";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import {
  DefaultRestBuilderProps,
  PlasmicRestBuilder,
  PlasmicRestBuilder__OverridesType,
} from "@/wab/client/plasmic/plasmic_kit_data_queries/PlasmicRestBuilder";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import ChevronDownsvgIcon from "@/wab/client/plasmic/q_4_icons/icons/PlasmicIcon__ChevronDownsvg";
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
import ChevronLeftsvgIcon from "@/wab/client/plasmic/q_4_icons/icons/PlasmicIcon__ChevronLeftsvg";
import {
  ensure,
  filterMapTruthy,
  hackyCast,
  uncheckedCast,
} from "@/wab/common";
import { StandardErrorBoundary } from "@/wab/commons/components/StandardErrors";
import { cloneRestQuery } from "@/wab/components";
import { codeLit, jsonLit, tryExtractString } from "@/wab/exprs";
import { mkNameArg } from "@/wab/lang";
import {
  BuiltinDataSourceQuery,
  getBuiltinDataSourceSpec,
  SimpleOpenAPIV2Spec,
} from "@/wab/shared/data/DataSources";
// import { evalRestQuery } from "./wab/shared/eval/eval";
import {
  ensureHttpMethod,
  HttpMethod,
  httpMethods,
  methodCanHaveBody,
} from "@/wab/shared/HttpClientUtil";

const debug = false;
const showDescriptions = false;

interface RestBuilderProps extends DefaultRestBuilderProps {
  query: RestQuery;
  onSubmit?: (query: RestQuery) => void;
}

export type RestFormData = RestQuery & {
  method: HttpMethod;
  authData?: AuthData;
};

interface ResponseSummary {
  response: Response;
  text?: string;
  json?: {};
}

type RequestStatus = "idle" | "loading";

function _RestBuilder(
  props: RestBuilderProps & { spec?: SimpleOpenAPIV2Spec }
) {
  const { query, onSubmit, spec, ...restProps } = props;
  const querySnapshot = useMemo(() => cloneRestQuery(query), []);
  const formMethods = useForm<RestFormData>({
    defaultValues: {
      ...querySnapshot,
      method: ensureHttpMethod(querySnapshot.method),
      authData: hackyCast(querySnapshot.authData),
    },
  });
  const { control, watch, handleSubmit, getValues } = formMethods;
  const qparams = useFieldArray({
    control,
    name: "queryParams",
  });
  const headers = useFieldArray({
    control,
    name: "headers",
  });

  const [showBody, setShowBody] = useState(true);
  const [requestStatus, setRequestStatus] = useState<RequestStatus>("idle");
  const [responseSummary, setResponseSummary] = useState<
    ResponseSummary | undefined
  >(undefined);
  // TODO to add
  const [showImporter, setShowImporter] = useState(false);

  function saveToNewQuery(data: RestFormData) {
    const newQuery = cloneRestQuery(data);
    newQuery.returnVar = query.returnVar;
    return newQuery;
  }

  async function runQuery(e: React.MouseEvent<HTMLButtonElement>) {
    e.preventDefault();
    const data = getValues();
    // TODO annoying.
    if (data.builtinQuery && querySnapshot.builtinQuery) {
      data.builtinQuery.type = querySnapshot.builtinQuery.type;
    }
    const _query = saveToNewQuery(data);
    setRequestStatus("loading");
    setResponseSummary(undefined);
    /*
    const { response, text, json } = await evalRestQuery(query);
    setRequestStatus("idle");
    setResponseSummary({
      response,
      text,
      json,
    });*/
  }

  function processSubmit(data: RestFormData) {
    onSubmit?.(saveToNewQuery(data));
  }

  function renderSection(
    group: typeof qparams | typeof headers,
    groupName: "queryParams" | "headers"
  ) {
    return group.fields.map((field, index) => (
      <KeyValueRow
        key={field.id}
        readOnlyKey
        readOnlyValue
        onIconButtonPress={() => group.remove(index)}
        keyLabel={
          <Controller
            name={`${groupName}.${index}.name` as const}
            control={control}
            defaultValue={field.name}
            render={({ field: f }) => (
              <Textbox
                styleType={["bordered"]}
                placeholder={"param name"}
                {...f}
              />
            )}
          />
        }
        value={
          <Controller
            name={`${groupName}.${index}.expr` as const}
            control={control}
            defaultValue={field.expr}
            render={({ field: f }) => (
              <Textbox
                styleType={["bordered"]}
                placeholder={"param value"}
                {...f}
                value={tryExtractString(f.value)}
                onChange={(e) => f.onChange(codeLit(e.target.value))}
              />
            )}
          />
        }
      />
    ));
  }

  function nameArgSectionProps(
    group: typeof qparams | typeof headers,
    groupName: "queryParams" | "headers"
  ) {
    return {
      props: {
        onIconButtonPress: () =>
          group.append(mkNameArg({ name: "", expr: jsonLit("") })),
        children: renderSection(group, groupName),
      },
    };
  }

  const responseProps: PlasmicRestBuilder__OverridesType = responseSummary
    ? {
        responseStatus: {
          children: `Response status: ${responseSummary.response.status} ${responseSummary.response.statusText}`,
        },
        responseData: {
          children:
            responseSummary.json !== undefined ? (
              <ValueViewer value={responseSummary.json} />
            ) : (
              responseSummary.text
            ),
        },
      }
    : {
        responseStatus: { children: "" },
        responseData: {
          children: requestStatus === "loading" ? <Spinner /> : "",
        },
      };

  function builtinProps(): PlasmicRestBuilder__OverridesType {
    if (!query.builtinQuery) {
      return {};
    }
    const spec2 = ensure(
      props.spec,
      "spec must be given when in builtinQuery mode"
    );
    // Annoyingly, must read fields to keep them around.
    watch("builtinQuery.type");
    const builtin: BuiltinDataSourceQuery = uncheckedCast(query.builtinQuery);
    switch (builtin.type) {
      case "WordpressQuery": {
        const endpointSpec = ensure(
          spec2.paths[watch("builtinQuery.endpoint")].get,
          () => `No endpoint spec`
        );
        return {
          topControls: {
            children: (
              <>
                <Controller
                  name={`builtinQuery.endpoint`}
                  control={control}
                  render={({ field }) => (
                    <Select value={field.value} onChange={field.onChange}>
                      {filterMapTruthy(
                        Object.entries(spec2.paths),
                        ([k, v]) =>
                          v.get && (
                            <Select.Option key={k} value={k}>
                              {!showDescriptions ? (
                                v.get.summary
                              ) : (
                                <div>
                                  <strong>{v.get.summary}</strong>
                                  {v.get.description &&
                                    ` - ${v.get.description}`}
                                </div>
                              )}
                            </Select.Option>
                          )
                      )}
                    </Select>
                  )}
                />
                <div className={"text-right"}>
                  {endpointSpec.externalDocs && (
                    <a href={endpointSpec.externalDocs.url}>Reference docs</a>
                  )}
                </div>
                <Controller
                  name={`builtinQuery.baseUrl`}
                  control={control}
                  render={({ field }) => (
                    <KeyValueRow
                      readOnlyKey
                      keyLabel={"Site URL"}
                      readOnlyValue
                      value={
                        <Textbox
                          styleType={["bordered"]}
                          placeholder={"Base URL"}
                          {...field}
                        />
                      }
                    />
                  )}
                />
              </>
            ),
          },
          builtinParams: {
            children: endpointSpec.parameters.map((p) => (
              <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                <KeyValueRow
                  key={p.name}
                  readOnlyKey
                  readOnlyValue
                  keyLabel={
                    <div className={"code"}>
                      {p.name + (p.required ? "*" : "")}
                    </div>
                  }
                  value={
                    <Controller
                      name={`builtinQuery.params.${p.name}` as any}
                      control={control}
                      render={({ field }) =>
                        p.type === "string" && p.enum ? (
                          <Select value={field.value} onChange={field.onChange}>
                            {[
                              <Select.Option value={null}>
                                (none)
                              </Select.Option>,
                              ...p.enum.map((e) => (
                                <Select.Option key={e} value={e}>
                                  {e}
                                </Select.Option>
                              )),
                            ]}
                          </Select>
                        ) : (
                          <Textbox
                            placeholder={"param value"}
                            styleType={["bordered"]}
                            value={field.value}
                            onChange={field.onChange}
                          />
                        )
                      }
                    />
                  }
                />
                <KeyValueRow
                  readOnlyKey
                  readOnlyValue
                  keyLabel={""}
                  value={<div style={{ marginLeft: 8 }}>{p.description}</div>}
                />
              </div>
            )),
          },
        };
      }
      case "AirtableQuery":
        return {
          builtinParams: {
            children: null,
          },
        };
    }
  }

  return (
    <FormProvider {...formMethods}>
      <form onSubmit={handleSubmit(processSubmit)}>
        <PlasmicRestBuilder
          {...restProps}
          doneButton={{ onClick: handleSubmit(processSubmit) }}
          builtInDataSource={!!query.builtinQuery}
          methodSelect={{
            render: (selectProps, Comp) => (
              <Controller
                name={"method"}
                control={control}
                render={({ field }) => (
                  <Comp
                    {...selectProps}
                    aria-label={"Method"}
                    value={field.value}
                    onChange={field.onChange}
                  >
                    {httpMethods.map((method) => (
                      <Select.Option value={method} key={method}>
                        {method}
                      </Select.Option>
                    ))}
                  </Comp>
                )}
              />
            ),
          }}
          urlInput={{
            render: (inputProps, Comp) => (
              <Controller
                name={"url"}
                control={control}
                render={({ field }) => (
                  <Comp
                    {...inputProps}
                    value={field.value}
                    onChange={field.onChange}
                  />
                )}
              />
            ),
          }}
          queryParamsSection={nameArgSectionProps(qparams, "queryParams")}
          headersSection={nameArgSectionProps(headers, "headers")}
          pathVariablesSection={{ render: () => null }}
          bodySection={{
            render: (sectionProps, Comp) =>
              methodCanHaveBody(watch("method")) && (
                <Comp
                  {...sectionProps}
                  onIconButtonPress={() => setShowBody(!showBody)}
                  icon={
                    showBody ? <ChevronDownsvgIcon /> : <ChevronLeftsvgIcon />
                  }
                >
                  {showBody && (
                    <Controller
                      control={control}
                      name={"payload"}
                      render={({ field }) => (
                        <PlasmicRestBuilder.bodyInput {...field} ref={null} />
                      )}
                    />
                  )}
                </Comp>
              ),
          }}
          previewButton={{
            onClick: runQuery,
          }}
          helpButton={{
            as: "a",
            props: {
              target: "_blank",
              href: "https://docs.plasmic.app/learn/rest-queries/",
            },
          }}
          // Hide for now until implemented.
          importButton={{
            render: () => null,
            props: {
              onClick: () => setShowImporter(true),
            },
          }}
          serverSideCheckbox={{
            render: (checkboxProps, Comp) => (
              <Controller
                control={control}
                name={"isServerSide"}
                render={({ field }) => (
                  <Comp
                    {...checkboxProps}
                    isChecked={field.value}
                    onChange={field.onChange}
                  >
                    <LabelWithDetailedTooltip
                      tooltip={
                        "When checked, this query will never be issued directly from the user's browser, but will always be run from Plasmic's servers. This prevents the auth data from being generated into the code that ships to browsers. Note that users are still able to call our servers with dynamic values for any expressions that are used in the query."
                      }
                    >
                      Run query on Plasmic servers
                    </LabelWithDetailedTooltip>
                  </Comp>
                )}
              />
            ),
          }}
          {...responseProps}
          {...builtinProps()}
        />
      </form>
      {debug && (
        <div style={{ fontFamily: "Roboto Mono", whiteSpace: "pre-wrap" }}>
          {util.inspect(watch())}
        </div>
      )}
    </FormProvider>
  );
}

function RestBuilder(props: RestBuilderProps) {
  const builtinQuery: BuiltinDataSourceQuery | undefined = hackyCast(
    props.query.builtinQuery
  );
  if (!builtinQuery) {
    return <_RestBuilder {...props} />;
  }
  const spec = getBuiltinDataSourceSpec(builtinQuery.type);
  return (
    <StandardErrorBoundary>
      <ReadablePromiseLoadable
        rp={spec}
        contents={(s) => <_RestBuilder {...props} spec={s} />}
      />
    </StandardErrorBoundary>
  );
}

export default RestBuilder;
